package DiseaseCloud

import HashMap
import TimerUtils
import LinkedList

constant boolean DEBUG = true
constant real DAMAGEFREQ = 1
constant string SFX = "Abilities\\Spells\\Undead\\PlagueCloud\\PlagueCloudCaster.mdl"

function debugMsg(string stringToPrint)
         if DEBUG
             print(stringToPrint)


function damage( unit source, real damage, real range )

    group targets = ENUM_GROUP

    debugMsg("Attempting to filter units!")
    targets.enumUnitsInRange(source.getPos(), range)

    //Filter Units
    for u in targets
        if( u == source or
            not u.isAlive() or
            u.getOwner().isAllyOf(source.getOwner()) 
            )

            targets.removeUnit(u)
            debugMsg("Removed "+u.getName())


    debugMsg("Filtered units!")

    int i = 0
    for u from targets
        debugMsg("Target "+i.toString()+": "+ u.getName() )
        source.damageTarget(u, damage)
        i++
        // Perhaps add a disease effect on the target


class Disease
    // The class that maintains the Disease Ability
    //----------------------------------------------
    private static constant boolean DISABLETRIGGERSONINIT = true
    private static constant boolean DAMAGESTACKS = false

    private static IterableMap<unit, timer> hitTargets

    private static IterableMap<unit, thistype> instances

    private static trigger trg_UnitDies
    private static trigger trg_UnitIsRemoved
     
    private static boolean hasBeenInitialized = false
    
    private real damageFrequency
    private real diseaseDamage
    private real diseaseRange
    private real cloudDamage
    private real cloudDuration
    private real cloudRange
    private player owner


    private unit unitWithAbility
    private effect sfx
    private timer timer_Damage

    ondestroy

    

    static function unitHasBeenHit( unit whichUnit) returns boolean
        if hitTargets != null
            return hitTargets.has(whichUnit)
        return false

    private construct(unit whichUnit, real diseaseDamage, real cloudDamage, real diseaseRange, real cloudRange, real cloudDuration, real damageFrequency)
        if not hasBeenInitialized
            debugMsg("Initializing Disease Class") 
            initialize()
    
        debugMsg("Adding Disease to "+whichUnit.getName()+"...") 
        instances.put(whichUnit, this)
        this.unitWithAbility = whichUnit
        this.diseaseDamage = diseaseDamage
        this.cloudDamage = cloudDamage
        this.cloudRange = cloudRange
        this.diseaseRange = diseaseRange
        this.cloudDuration = cloudDuration
        this.damageFrequency = damageFrequency

        sfx = unitWithAbility.addEffect(SFX, "origin")
        timer_Damage = getTimer()
        ..setData(this castTo int)
        ..startPeriodic(damageFrequency, function orderDamage)

        

        debugMsg("Finished adding Disease to unit")
            


    /** A simple addUnit. The parameters are for both the disease and the cloud. Damage frequency is 1 second. */
    static function addUnit(unit whichUnit, real damage, real cloudDuration, real range)
        debugMsg("Disease: addUnit() called")
        new Disease(whichUnit, damage, damage, range, range, cloudDuration, 1)

    /** A custom addUnit. Full control over the disease and the cloud.*/
    static function addUnit(unit whichUnit, real diseaseDamage, real cloudDamage, real diseaseRange, real cloudRange, real cloudDuration, real damageFrequency)
        debugMsg("Disease: addUnit() called")
        new Disease(whichUnit, diseaseDamage, cloudDamage, diseaseRange, cloudRange, cloudDuration, damageFrequency)

    /** Removes the unit from the Disease stack
     (basically removing the Disease ) from the unit*/
    static function removeUnit(unit unitToRemove)
        if instances.has(unitToRemove)
            destroy instances.get(unitToRemove)

    private static function targetFilter()

    

    private static function orderDamage()
        thistype instance = GetExpiredTimer().getData() castTo thistype
        damage(instance.unitWithAbility, instance.diseaseDamage, instance.diseaseRange)
        


        

    private static function unitDies() returns boolean
        unit dyingUnit = GetDyingUnit()
        
        if instances.has(dyingUnit)
            thistype instance = instances.get(dyingUnit)       
            new DiseaseCloud(instance.owner, instance.unitWithAbility.getPos(), instance.cloudDamage, instance.cloudDuration, instance.cloudRange)
            destroy instance

        return false


    private static function unitIsRemoved() returns boolean
        // It's not tested if you leave the map rect when you get moved
        // To another place in the map.
        unit removedUnit = GetLeavingUnit()

        if instances.has(removedUnit)
            destroy instances.get(removedUnit)

        return false


    /** Activates Unit death and removal detection (the triggers)  */
    static function activate()
        trg_UnitDies.enable()
        trg_UnitIsRemoved.disable()

    /** Deactivates Unit death and removal detection (the triggers)  */
    static function deactivate()
        trg_UnitDies.disable()
        trg_UnitIsRemoved.disable()
        

    private static function initialize()
        
        if not hasBeenInitialized
            hasBeenInitialized = true

            instances = new IterableMap<unit, thistype>
            hitTargets = new IterableMap<unit, timer>

            trg_UnitDies = CreateTrigger()
            ..addCondition(Condition(function unitDies))

            trg_UnitIsRemoved = CreateTrigger()
            ..addCondition(Condition(function unitIsRemoved))

            if( DISABLETRIGGERSONINIT )
                trg_UnitDies.disable()
                trg_UnitIsRemoved.disable()



class DiseaseCloud
    // The class that maintains the disease clouds after unit death

    private static LinkedList<thistype> instances

    private static boolean hasBeenInitialized

    timer timer_Damage
    timer timer_Duration
    real damage
    vec2 pos
    player owner
    unit dummy
    real range
    effect sfx

    

    ondestroy
        instances.remove(this)
        dummy.remove()
        sfx.destr()
        timer_Damage.release()
        timer_Duration.release()

    static function orderDamage()
        thistype instance = GetExpiredTimer().getData() castTo thistype
        damage(instance.dummy, instance.damage, instance.range)


    construct(player owner, vec2 pos, real damage, real duration, real range)
        debugMsg("Creating new cloud! Stats: "+
                    "Player"+owner.getId().toString()+
                    ", Position:"+pos.toString()+
                    ", Damage: "+damage.toString()+
                    ", Duration: "+duration.toString()+
                    ", Range: "+range.toString() )
        if not hasBeenInitialized
            initialize()

        instances.add(this)
            
        this.owner = owner
        this.pos = pos
        this.damage = damage
        this.range = range

        sfx = addEffect(SFX, pos.withTerrainZ(100) ) 
        dummy = createUnit(owner, 'h004', pos, angle(0) )
        
        timer_Duration = getTimer()
        if duration>0
            timer_Duration
            ..setData(this castTo int)
            ..start( duration+0.1, () -> destroy GetExpiredTimer().getData() castTo thistype )

        timer_Damage = getTimer()
        ..setData(this castTo int)
        ..startPeriodic( DAMAGEFREQ, function orderDamage )

        
    static function destroyAll()
        for instance in instances
            destroy instance


    /** 
    Initialize the class: creating instance list.
    It's automatically initialized when creating
    a new instance */

    private static function initialize()
        debugMsg("Initializing DiseaseCloud class")
        if not hasBeenInitialized
            hasBeenInitialized = true
            instances = new LinkedList<thistype>


function delayedInit()
    GetExpiredTimer().release()
    unit u = createUnit(Player(0), 'hfoo', vec2(-13935,-14250), angle(0))
    Disease.addUnit(u, 50, 10, 300)


init
    getTimer().start(1, function delayedInit )
    

    